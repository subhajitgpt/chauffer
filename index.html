<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Chauffer - Your Car. Our Trusted Driver.</title>

  <style>
    :root { color-scheme: light; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background: #0b1220; color: #e8eefc; }
    a { color: inherit; text-decoration: none; }

    header { position: sticky; top: 0; z-index: 20; backdrop-filter: blur(10px); background: rgba(11,18,32,0.75); border-bottom: 1px solid rgba(255,255,255,0.10); }
    .bar { max-width: 1140px; margin: 0 auto; padding: 14px 18px; display:flex; align-items:center; justify-content: space-between; gap: 12px; }
    .brand { display:flex; gap: 10px; align-items:center; font-weight: 850; letter-spacing: 0.2px; }
    .brand .dot { width: 10px; height: 10px; border-radius: 999px; background: #2b6cff; }

    nav { display:flex; gap: 12px; align-items:center; flex-wrap: wrap; }
    nav a { color: rgba(232,238,252,0.85); font-size: 13px; }
    nav a:hover { color: rgba(232,238,252,1); }

    .btn { cursor: pointer; border: 0; border-radius: 12px; padding: 10px 12px; font-weight: 700; }
    .btn.primary { background: #2b6cff; color: white; }
    .btn.ghost { background: rgba(255,255,255,0.10); color: rgba(232,238,252,0.95); border: 1px solid rgba(255,255,255,0.14); }
    .btn.link { background: transparent; color: rgba(232,238,252,0.9); padding: 8px 8px; }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; }

    .wrap { max-width: 1140px; margin: 0 auto; padding: 18px; }

    .hero { padding: 24px 0 10px; }
    .heroGrid { display:grid; grid-template-columns: 1.15fr 0.85fr; gap: 16px; align-items: start; }
    @media (max-width: 980px) { .heroGrid { grid-template-columns: 1fr; } }

    h1 { margin: 0 0 10px; font-size: 44px; line-height: 1.05; letter-spacing: -0.5px; }
    @media (max-width: 680px) { h1 { font-size: 34px; } }
    .sub { margin: 0 0 16px; color: rgba(232,238,252,0.80); font-size: 15px; line-height: 1.55; }

    .badges { display:flex; gap: 10px; flex-wrap: wrap; margin: 14px 0 0; }
    .badge { display:flex; align-items:center; gap: 8px; border: 1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.06); color: rgba(232,238,252,0.85);
      border-radius: 999px; padding: 8px 10px; font-size: 12px; }
    .badge .b { width: 7px; height: 7px; border-radius: 999px; background: rgba(43,108,255,0.95); }

    .card { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.12); border-radius: 16px; padding: 16px; }
    .card h2 { margin: 0 0 10px; font-size: 18px; }

    .tabs { display:flex; flex-wrap: wrap; gap: 8px; margin-bottom: 12px; }
    .tab { padding: 10px 12px; border-radius: 999px; border: 1px solid rgba(255,255,255,0.16); background: rgba(0,0,0,0.18); color: rgba(232,238,252,0.9); cursor: pointer; }
    .tab.active { background: #2b6cff; border-color: rgba(43,108,255,0.9); color: white; }

    label { display:block; font-size: 13px; margin: 10px 0 6px; color: rgba(232,238,252,0.85); }
    input { width: 100%; box-sizing: border-box; padding: 12px 12px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.16); background: rgba(0,0,0,0.22); color: #e8eefc; outline: none; }
    input:focus { border-color: rgba(116,165,255,0.7); }

    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    @media (max-width: 680px) { .grid2 { grid-template-columns: 1fr; } }

    .actions { display:flex; gap: 10px; flex-wrap: wrap; margin-top: 12px; }

    .miniActions { display:flex; gap: 8px; flex-wrap: wrap; margin-top: 8px; }
    .btn.small { padding: 8px 10px; border-radius: 999px; font-size: 12px; }
    .hint { font-size: 12px; color: rgba(232,238,252,0.72); margin-top: 8px; line-height: 1.35; }

    #map { width: 100%; height: 420px; border-radius: 16px; overflow: hidden; border: 1px solid rgba(255,255,255,0.12); background: rgba(0,0,0,0.20); }

    .kpis { display:flex; gap: 10px; flex-wrap: wrap; margin-top: 12px; }
    .kpi { flex: 1; min-width: 160px; background: rgba(0,0,0,0.22); border: 1px solid rgba(255,255,255,0.12); border-radius: 14px; padding: 10px 12px; }
    .kpi .label { font-size: 12px; color: rgba(232,238,252,0.7); }
    .kpi .value { font-size: 16px; font-weight: 800; margin-top: 4px; }

    .msg { margin-top: 10px; padding: 10px 12px; border-radius: 12px; background: rgba(0,0,0,0.25); border: 1px solid rgba(255,255,255,0.12); min-height: 20px; color: rgba(232,238,252,0.92); }

    section { padding: 16px 0; }
    .sectionTitle { margin: 0 0 10px; font-size: 22px; }
    .muted { color: rgba(232,238,252,0.75); }

    .grid3 { display:grid; grid-template-columns: repeat(3, 1fr); gap: 12px; }
    @media (max-width: 980px) { .grid3 { grid-template-columns: 1fr; } }

    .pill { display:inline-flex; align-items:center; gap: 8px; font-size: 12px; color: rgba(232,238,252,0.85);
      border: 1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.06); border-radius: 999px; padding: 8px 10px; }

    footer { border-top: 1px solid rgba(255,255,255,0.10); padding: 20px 0 26px; margin-top: 12px; }
    .footGrid { display:grid; grid-template-columns: 1.2fr 1fr 1fr; gap: 16px; }
    @media (max-width: 980px) { .footGrid { grid-template-columns: 1fr; } }

    /* Login overlay (single-file ‚Äúlogin page‚Äù)
       Shown when not authenticated.
    */
    .overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.62); z-index: 50; display: none; }
    .overlay.show { display:block; }
    .modal { max-width: 560px; margin: 8vh auto; padding: 0 18px; }
    .modalCard { background: rgba(11,18,32,0.98); border: 1px solid rgba(255,255,255,0.14); border-radius: 18px; padding: 16px; }
    .modalCard h2 { margin: 0 0 6px; }
    .tiny { font-size: 12px; color: rgba(232,238,252,0.7); line-height: 1.4; }
    code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>

  <!-- Pyodide (Python in-browser) -->
  <script src="https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js"></script>
</head>
<body>
  <header>
    <div class="bar">
      <div class="brand"><span class="dot"></span><span>Chauffer</span></div>
      <nav>
        <a href="#how">How it Works</a>
        <a href="#safety">Safety</a>
        <a href="#pricing">Pricing</a>
      </nav>
      <div style="display:flex; gap: 8px; align-items:center;">
        <button id="whoBtn" class="btn link" type="button" style="display:none"></button>
        <button id="loginBtn" class="btn ghost" type="button">Login</button>
        <button id="bookNowBtn" class="btn primary" type="button">Book Now</button>
      </div>
    </div>
  </header>

  <!-- Login overlay (single-file "login page") -->
  <div id="loginOverlay" class="overlay" aria-hidden="true">
    <div class="modal">
      <div class="modalCard">
        <div style="display:flex; justify-content: space-between; align-items: center; gap: 10px;">
          <h2>Login / Register</h2>
          <button id="closeLogin" class="btn ghost" type="button">Close</button>
        </div>
        <div class="tiny">Phone-based registration stored locally (demo ‚Äúbackend‚Äù). OTP is generated in Pyodide and shown on screen.</div>

        <label for="phone">Phone number</label>
        <input id="phone" type="tel" placeholder="+91XXXXXXXXXX" autocomplete="tel" />

        <div class="actions">
          <button id="register" class="btn ghost" type="button">Register</button>
          <button id="genOtp" class="btn primary" type="button">Generate OTP</button>
        </div>

        <label for="otp">OTP</label>
        <div class="grid2">
          <div>
            <input id="otp" type="text" placeholder="6-digit OTP" inputmode="numeric" />
          </div>
          <div>
            <button id="verify" class="btn primary" type="button">Verify</button>
          </div>
        </div>

        <div id="loginMsg" class="msg"></div>
        <div class="tiny" style="margin-top: 10px;">
          If you truly need a backend capture + SMS delivery, you‚Äôll need a server. This file keeps everything self-contained as requested.
        </div>
      </div>
    </div>
  </div>

  <main class="wrap">
    <section class="hero">
      <div class="heroGrid">
        <div>
          <h1>Your Car. Our Trusted Driver.</h1>
          <p class="sub">Long trips, parties, emergencies‚Äîbook a verified driver for your own car in minutes. Safe, reliable, and always there when you need.</p>
          <div class="actions">
            <button id="bookNowBtn2" class="btn primary" type="button">Book a Driver Now</button>
            <button id="becomeBtn" class="btn ghost" type="button">Become a Driver</button>
          </div>
          <div class="badges">
            <div class="badge"><span class="b"></span> Police Verified</div>
            <div class="badge"><span class="b"></span> 4.8 Rating</div>
            <div class="badge"><span class="b"></span> 50,000+ Trips</div>
          </div>
        </div>

        <div class="card" id="book">
          <h2>Book a Driver</h2>
          <div class="tabs" id="tripTabs">
            <button class="tab active" type="button" data-type="one_way">One Way</button>
            <button class="tab" type="button" data-type="round_trip">Round Trip</button>
            <button class="tab" type="button" data-type="hourly">Hourly</button>
            <button class="tab" type="button" data-type="after_party">After Party</button>
          </div>

          <label for="pickup">Pickup</label>
          <input id="pickup" type="text" placeholder="Enter pickup location" autocomplete="off" />
          <div class="miniActions">
            <button id="useMyLocation" class="btn ghost small" type="button">Use my location (Pickup)</button>
            <button id="trackMe" class="btn ghost small" type="button">Track me</button>
          </div>

          <label for="drop">Drop</label>
          <input id="drop" type="text" placeholder="Enter drop location" autocomplete="off" />
          <div class="miniActions">
            <button id="useMyLocationDrop" class="btn ghost small" type="button">Use my location (Drop)</button>
          </div>
          <div class="hint">Tip: you can also click on the map to set Pickup/Drop (focus the input first).</div>

          <div class="grid2">
            <div>
              <label for="date">Date</label>
              <input id="date" type="date" />
            </div>
            <div>
              <label for="time">Time</label>
              <input id="time" type="time" />
            </div>
          </div>

          <div class="actions">
            <button id="routeBtn" class="btn ghost" type="button" disabled>Show Route</button>
            <button id="findBtn" class="btn primary" type="button" disabled>Find Drivers</button>
          </div>

          <div class="kpis">
            <div class="kpi"><div class="label">Distance</div><div class="value" id="dist">‚Äî</div></div>
            <div class="kpi"><div class="label">Duration</div><div class="value" id="dur">‚Äî</div></div>
            <div class="kpi"><div class="label">Estimated fare</div><div class="value" id="fare">‚Äî</div></div>
          </div>

          <div id="msg" class="msg">Loading‚Ä¶</div>

          <div id="driversPanel" class="card" style="margin-top: 12px; display:none;">
            <div style="display:flex; align-items:center; justify-content: space-between; gap: 10px;">
              <div style="font-weight: 850;">Choose Your Driver</div>
              <button id="closeDrivers" class="btn ghost small" type="button">Hide</button>
            </div>
            <div id="driversStatus" class="hint" style="margin-top: 6px;">Available drivers will appear here.</div>
            <div id="driversList" style="margin-top: 10px; display:grid; gap: 10px;"></div>
          </div>
        </div>
      </div>

      <div style="margin-top: 16px;">
        <div id="map"></div>
      </div>
    </section>

    <section id="safety">
      <h2 class="sectionTitle">Why Choose DriveMate?</h2>
      <div class="muted" style="margin-bottom: 10px;">India‚Äôs most trusted platform for on-demand personal drivers</div>
      <div class="grid3">
        <div class="card"><div class="pill">Verified Drivers</div><div style="margin-top:10px" class="muted">Background verified with license & ID checks.</div></div>
        <div class="card"><div class="pill">Available 24/7</div><div style="margin-top:10px" class="muted">Emergency drivers within 15 minutes, anytime you need.</div></div>
        <div class="card"><div class="pill">Rated & Reviewed</div><div style="margin-top:10px" class="muted">Choose from top-rated drivers with real customer feedback.</div></div>
      </div>
    </section>

    <section id="how">
      <h2 class="sectionTitle">How DriveMate Works</h2>
      <div class="grid3">
        <div class="card"><div class="pill">01</div><div style="margin-top:10px">Enter Trip Details</div><div class="muted" style="margin-top:6px">Pickup & drop, date, time, trip type.</div></div>
        <div class="card"><div class="pill">02</div><div style="margin-top:10px">Choose Your Driver</div><div class="muted" style="margin-top:6px">Browse verified drivers with ratings & experience.</div></div>
        <div class="card"><div class="pill">03</div><div style="margin-top:10px">Track & Reach Safely</div><div class="muted" style="margin-top:6px">Real-time tracking, SOS, secure payment.</div></div>
      </div>
    </section>

    <section id="pricing">
      <h2 class="sectionTitle">Featured Drivers</h2>
      <div class="muted" style="margin-bottom: 10px;">Handpicked drivers with excellent track records</div>
      <div class="grid3">
        <div class="card"><div style="font-weight:800">Rajesh Kumar</div><div class="muted" style="margin-top:6px">Delhi NCR ‚Ä¢ 4.9 ‚Ä¢ 5+ yrs</div><div style="margin-top:10px"><span class="pill">‚Çπ199 / hour</span></div></div>
        <div class="card"><div style="font-weight:800">Amit Singh</div><div class="muted" style="margin-top:6px">Mumbai ‚Ä¢ 4.8 ‚Ä¢ 3+ yrs</div><div style="margin-top:10px"><span class="pill">‚Çπ249 / hour</span></div></div>
        <div class="card"><div style="font-weight:800">Suresh Yadav</div><div class="muted" style="margin-top:6px">Bangalore ‚Ä¢ 4.7 ‚Ä¢ 8+ yrs</div><div style="margin-top:10px"><span class="pill">‚Çπ179 / hour</span></div></div>
      </div>
    </section>

    <section>
      <h2 class="sectionTitle">Perfect For Every Situation</h2>
      <div class="grid3">
        <div class="card"><div class="pill">After Party</div><div class="muted" style="margin-top:10px">Get home safe with a verified driver.</div></div>
        <div class="card"><div class="pill">Long Road Trips</div><div class="muted" style="margin-top:10px">Multi-day trips with an experienced driver.</div></div>
        <div class="card"><div class="pill">Emergencies</div><div class="muted" style="margin-top:10px">Urgent travel‚Äîdrivers ready 24/7.</div></div>
      </div>
    </section>

    <footer>
      <div class="footGrid">
        <div>
          <div style="font-weight:850; font-size: 16px;">DriveMate</div>
          <div class="muted" style="margin-top: 8px;">We don‚Äôt provide cars. We provide the most trusted human in the car.</div>
        </div>
        <div>
          <div style="font-weight:800">Quick Links</div>
          <div class="muted" style="margin-top: 8px; display:grid; gap: 6px;">
            <a href="#how">How it Works</a>
            <a href="#safety">Safety</a>
            <a href="#pricing">Pricing</a>
          </div>
        </div>
        <div>
          <div style="font-weight:800">Support</div>
          <div class="muted" style="margin-top: 8px; display:grid; gap: 6px;">
            <div>support@drivemate.in</div>
            <div>1800-123-4567</div>
            <div>Bangalore, Karnataka, India</div>
          </div>
        </div>
      </div>
      <div class="muted" style="margin-top: 14px; font-size: 12px;">¬© 2024 DriveMate India. All rights reserved.</div>
    </footer>
  </main>

  <script>
    // ============================================================
    // Single-file app constraints:
    // - "Backend capture" is implemented via localStorage (demo).
    // - OTP is generated/verified locally using Pyodide (Python).
    // - Google Maps key is decrypted in Pyodide to match encrypt_keys.py.
    // ============================================================

    const GMAPS_KEY_ENCRYPTED = "Qs5skmSuUzGSs5TwYxnoazaHLEgJ995LrvyyWiziwWdIzkyAfrYq";
    const PASSPHRASE = "default_salt_2024";

    const $ = (id) => document.getElementById(id);

    function setMsg(text) { $("msg").textContent = text; }
    function setLoginMsg(text) { $("loginMsg").textContent = text; }

    function normalizePhone(phone) {
      const s = String(phone || "").trim();
      const cleaned = s.split("").filter(ch => (ch >= "0" && ch <= "9") || ch === "+").join("");
      if (!cleaned) throw new Error("Phone is required");
      return cleaned;
    }

    function getDb() {
      return JSON.parse(localStorage.getItem("chauffer_db") || "{}") || {};
    }
    function setDb(db) {
      localStorage.setItem("chauffer_db", JSON.stringify(db));
    }

    function uid(prefix) {
      return `${prefix}_${Date.now()}_${Math.floor(Math.random() * 1e9)}`;
    }

    function getSession() {
      return JSON.parse(localStorage.getItem("chauffer_session") || "null");
    }
    function setSession(session) {
      localStorage.setItem("chauffer_session", JSON.stringify(session));
    }
    function clearSession() {
      localStorage.removeItem("chauffer_session");
    }

    function isAuthed() {
      const s = getSession();
      return !!(s && s.phone && s.verified);
    }

    function showLogin(show) {
      const el = $("loginOverlay");
      el.classList.toggle("show", !!show);
      el.setAttribute("aria-hidden", show ? "false" : "true");
    }

    function updateHeaderAuthUI() {
      const loginBtn = $("loginBtn");
      const whoBtn = $("whoBtn");

      if (isAuthed()) {
        const s = getSession();
        loginBtn.textContent = "Logout";
        whoBtn.style.display = "inline-block";
        whoBtn.textContent = s.phone;
      } else {
        loginBtn.textContent = "Login";
        whoBtn.style.display = "none";
        whoBtn.textContent = "";
      }
    }

    // Trip type tabs
    let tripType = "one_way";
    $("tripTabs").addEventListener("click", (e) => {
      const btn = e.target.closest("button[data-type]");
      if (!btn) return;
      tripType = btn.getAttribute("data-type");
      for (const el of $("tripTabs").querySelectorAll(".tab")) el.classList.remove("active");
      btn.classList.add("active");
    });

    // Smooth scroll to booking card
    function scrollToBooking() {
      const el = document.getElementById("book");
      el.scrollIntoView({ behavior: "smooth", block: "start" });
    }
    $("bookNowBtn").addEventListener("click", scrollToBooking);
    $("bookNowBtn2").addEventListener("click", scrollToBooking);
    $("becomeBtn").addEventListener("click", () => alert("Demo UI only."));

    $("loginBtn").addEventListener("click", () => {
      if (isAuthed()) {
        clearSession();
        updateHeaderAuthUI();
        setMsg("Logged out.");
        return;
      }
      showLogin(true);
      setLoginMsg("Enter phone number to register/login.");
    });
    $("closeLogin").addEventListener("click", () => showLogin(false));

    // Google Maps
    let map, directionsService, directionsRenderer;
    let pickupAutocomplete, dropAutocomplete;
    let pickupPlace = null;
    let dropPlace = null;

    let pickupMarker = null;
    let dropMarker = null;

    let trafficLayer = null;

    // Driver selection (single-file demo)
    const DRIVERS = [
      { id: "d1", name: "Rajesh Kumar", rating: 4.9, trips: 523, years: 5, city: "Delhi NCR", pricePerHour: 199, verified: true },
      { id: "d2", name: "Amit Singh", rating: 4.8, trips: 341, years: 3, city: "Mumbai", pricePerHour: 249, verified: true },
      { id: "d3", name: "Suresh Yadav", rating: 4.7, trips: 892, years: 8, city: "Bangalore", pricePerHour: 179, verified: true },
      { id: "d4", name: "Vikram Mehta", rating: 4.6, trips: 215, years: 4, city: "Pune", pricePerHour: 209, verified: true },
      { id: "d5", name: "Imran Khan", rating: 4.8, trips: 610, years: 6, city: "Hyderabad", pricePerHour: 189, verified: true },
      { id: "d6", name: "Rohit Sharma", rating: 4.7, trips: 455, years: 5, city: "Chennai", pricePerHour: 199, verified: true },
    ];

    let activeBookingId = null;
    let acceptanceTimerId = null;

    // Driver movement simulation
    let driverMarker = null;
    let driverSimTimer = null;
    let driverSimBookingId = null;
    let driverRouteLine = null;

    // Location tracking
    let geoWatchId = null;
    let userMarker = null;
    let userAccuracyCircle = null;
    let geocoder = null;

    let lastFocusedField = "pickup";

    function updateButtons() {
      const ok = !!(pickupPlace && dropPlace);
      $("routeBtn").disabled = !ok;
      $("findBtn").disabled = !ok;
    }

    function showDriversPanel(show) {
      const panel = $("driversPanel");
      if (!panel) return;
      panel.style.display = show ? "block" : "none";
    }

    function setDriversStatus(text) {
      const el = $("driversStatus");
      if (el) el.textContent = text;
    }

    function getBookingById(db, bookingId) {
      const list = db.bookings || [];
      return list.find((b) => b && b.id === bookingId) || null;
    }

    function updateBooking(db, bookingId, patch) {
      db.bookings = db.bookings || [];
      const idx = db.bookings.findIndex((b) => b && b.id === bookingId);
      if (idx < 0) return null;
      db.bookings[idx] = { ...db.bookings[idx], ...patch };
      return db.bookings[idx];
    }

    function renderDriversList(bookingId) {
      const listEl = $("driversList");
      if (!listEl) return;
      listEl.innerHTML = "";

      const db = getDb();
      const booking = getBookingById(db, bookingId);

      for (const d of DRIVERS) {
        const card = document.createElement("div");
        card.className = "card";
        card.style.padding = "12px";

        const top = document.createElement("div");
        top.style.display = "flex";
        top.style.justifyContent = "space-between";
        top.style.alignItems = "center";
        top.style.gap = "10px";

        const left = document.createElement("div");
        left.innerHTML = `
          <div style="font-weight:850;">${d.name} ${d.verified ? '<span class="pill" style="margin-left:6px;">Verified</span>' : ''}</div>
          <div class="muted" style="margin-top:4px; font-size: 13px;">‚≠ê ${d.rating} ‚Ä¢ ${d.trips} trips ‚Ä¢ ${d.years}+ yrs ‚Ä¢ ${d.city}</div>
          <div style="margin-top:8px;"><span class="pill">‚Çπ${d.pricePerHour} / hour</span></div>
        `;

        const btn = document.createElement("button");
        btn.className = "btn primary small";
        btn.type = "button";
        btn.textContent = "Request";

        const status = booking?.status;
        const selectedId = booking?.driver?.id;
        if (status === "accepted" && selectedId === d.id) {
          btn.textContent = "Accepted";
          btn.disabled = true;
        } else if (status === "arrived" && selectedId === d.id) {
          btn.textContent = "Arrived";
          btn.disabled = true;
        } else if (status === "requested") {
          btn.textContent = selectedId === d.id ? "Requested" : "Request";
          btn.disabled = true; // lock selection while pending
        } else if (status === "accepted") {
          btn.disabled = true; // one accepted driver per booking
        } else if (status === "arrived") {
          btn.disabled = true;
        }

        btn.addEventListener("click", () => requestDriverForBooking(bookingId, d));

        top.appendChild(left);
        top.appendChild(btn);
        card.appendChild(top);
        listEl.appendChild(card);
      }
    }

    function requestDriverForBooking(bookingId, driver) {
      if (!isAuthed()) {
        showLogin(true);
        setLoginMsg("Login required to request a driver.");
        return;
      }

      const db = getDb();
      const booking = getBookingById(db, bookingId);
      if (!booking) {
        setMsg("No active booking found.");
        return;
      }

      if (booking.status === "accepted") {
        setDriversStatus(`Driver already accepted: ${booking.driver?.name || ""}`);
        return;
      }

      updateBooking(db, bookingId, {
        status: "requested",
        driver: { id: driver.id, name: driver.name, rating: driver.rating, pricePerHour: driver.pricePerHour },
        requestedAt: Date.now(),
      });
      setDb(db);

      setDriversStatus(`Request sent to ${driver.name}. Waiting for acceptance‚Ä¶`);
      renderDriversList(bookingId);

      if (acceptanceTimerId) {
        clearTimeout(acceptanceTimerId);
        acceptanceTimerId = null;
      }

      // Simulate acceptance (demo)
      const delayMs = 3000 + Math.floor(Math.random() * 5000);
      acceptanceTimerId = setTimeout(() => {
        const db2 = getDb();
        const b2 = getBookingById(db2, bookingId);
        if (!b2 || b2.status !== "requested" || b2.driver?.id !== driver.id) return;
        updateBooking(db2, bookingId, { status: "accepted", acceptedAt: Date.now() });
        setDb(db2);
        setDriversStatus(`Accepted by ${driver.name}. Driver is on the way.`);
        renderDriversList(bookingId);

        // Start simulated driver movement towards pickup.
        try {
          startDriverSimulationTowardPickup(bookingId);
        } catch (_) {
          // ignore
        }
      }, delayMs);
    }

    function stopDriverSimulation() {
      if (driverSimTimer) {
        clearInterval(driverSimTimer);
        driverSimTimer = null;
      }
      driverSimBookingId = null;

      if (driverRouteLine) {
        try { driverRouteLine.setMap(null); } catch (_) {}
        driverRouteLine = null;
      }
    }

    function getDistanceMeters(a, b) {
      try {
        if (google?.maps?.geometry?.spherical?.computeDistanceBetween) {
          return google.maps.geometry.spherical.computeDistanceBetween(a, b);
        }
      } catch (_) {}
      // Fallback haversine
      const R = 6371000;
      const toRad = (x) => (x * Math.PI) / 180;
      const lat1 = a.lat();
      const lon1 = a.lng();
      const lat2 = b.lat();
      const lon2 = b.lng();
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const sLat1 = toRad(lat1);
      const sLat2 = toRad(lat2);
      const h =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(sLat1) * Math.cos(sLat2) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
      return 2 * R * Math.asin(Math.min(1, Math.sqrt(h)));
    }

    function interpolateLatLng(a, b, t) {
      const lat = a.lat() + (b.lat() - a.lat()) * t;
      const lng = a.lng() + (b.lng() - a.lng()) * t;
      return new google.maps.LatLng(lat, lng);
    }

    function interpolateSpherical(a, b, t) {
      try {
        if (google?.maps?.geometry?.spherical?.interpolate) {
          return google.maps.geometry.spherical.interpolate(a, b, t);
        }
      } catch (_) {}
      return interpolateLatLng(a, b, t);
    }

    function computeHeading(a, b) {
      try {
        if (google?.maps?.geometry?.spherical?.computeHeading) {
          return google.maps.geometry.spherical.computeHeading(a, b);
        }
      } catch (_) {}
      return 0;
    }

    function ensureDriverMarker(startLatLng) {
      if (!map) throw new Error("Map not ready");
      if (!driverMarker) {
        driverMarker = new google.maps.Marker({
          map,
          position: startLatLng,
          title: "Driver",
          label: { text: "üöó", fontSize: "14px" },
          icon: {
            path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
            scale: 5,
            fillColor: "#2b6cff",
            fillOpacity: 1,
            strokeColor: "#ffffff",
            strokeWeight: 2,
            rotation: 0,
          },
        });
      } else {
        driverMarker.setMap(map);
        driverMarker.setPosition(startLatLng);
      }
    }

    async function startDriverSimulationTowardPickup(bookingId) {
      if (!pickupPlace?.geometry?.location) return;

      const db = getDb();
      const booking = getBookingById(db, bookingId);
      if (!booking || booking.status !== "accepted") return;

      stopDriverSimulation();
      driverSimBookingId = bookingId;

      const pickupLatLng = pickupPlace.geometry.location;
      // Start a short distance away with a small random offset.
      const start = new google.maps.LatLng(
        pickupLatLng.lat() + (Math.random() - 0.5) * 0.02,
        pickupLatLng.lng() + (Math.random() - 0.5) * 0.02
      );

      ensureDriverMarker(start);

      // Get a real road route from driver start -> pickup.
      let routePath = null;
      try {
        if (!directionsService) throw new Error("DirectionsService not ready");
        const res = await directionsService.route({
          origin: start,
          destination: pickupLatLng,
          travelMode: google.maps.TravelMode.DRIVING,
          drivingOptions: {
            departureTime: new Date(),
            trafficModel: google.maps.TrafficModel.BEST_GUESS,
          },
        });
        routePath = res.routes?.[0]?.overview_path || null;
      } catch (_) {
        routePath = null;
      }

      if (!Array.isArray(routePath) || routePath.length < 2) {
        // Fallback: straight-line if route isn't available.
        routePath = [start, pickupLatLng];
      }

      // Show a subtle driver route line (optional but helps visually).
      try {
        driverRouteLine = new google.maps.Polyline({
          path: routePath,
          map,
          strokeColor: "#2b6cff",
          strokeOpacity: 0.35,
          strokeWeight: 4,
        });
      } catch (_) {
        driverRouteLine = null;
      }

      // Animate along the route path.
      let segIndex = 0;
      let segT = 0;
      const speedMps = 18; // ~65 km/h equivalent for demo

      driverSimTimer = setInterval(() => {
        try {
          const db2 = getDb();
          const b2 = getBookingById(db2, bookingId);
          if (!b2 || (b2.status !== "accepted" && b2.status !== "arrived")) {
            stopDriverSimulation();
            return;
          }
          if (b2.status === "arrived") {
            stopDriverSimulation();
            return;
          }

          let current = driverMarker?.getPosition();
          if (!current) current = routePath[0];

          const distToPickup = getDistanceMeters(current, pickupLatLng);
          if (distToPickup <= 35 || segIndex >= routePath.length - 1) {
            updateBooking(db2, bookingId, { status: "arrived", arrivedAt: Date.now() });
            setDb(db2);
            setDriversStatus(`Driver arrived at pickup: ${b2.driver?.name || ""}`);
            renderDriversList(bookingId);
            setMsg("Driver arrived at pickup.");
            stopDriverSimulation();
            return;
          }

          let remainingMove = speedMps; // per 1s tick
          let newPos = current;

          while (remainingMove > 0 && segIndex < routePath.length - 1) {
            const a = routePath[segIndex];
            const b = routePath[segIndex + 1];
            const segLen = Math.max(1, getDistanceMeters(a, b));
            const segRemaining = segLen * (1 - segT);

            if (remainingMove < segRemaining) {
              segT = segT + (remainingMove / segLen);
              newPos = interpolateSpherical(a, b, segT);
              remainingMove = 0;
            } else {
              // jump to end of segment
              newPos = b;
              remainingMove -= segRemaining;
              segIndex += 1;
              segT = 0;
            }
          }

          // Update heading (nice touch)
          try {
            const nextTarget = routePath[Math.min(segIndex + 1, routePath.length - 1)];
            const heading = computeHeading(newPos, nextTarget);
            const icon = driverMarker.getIcon();
            if (icon && typeof icon === "object") {
              driverMarker.setIcon({ ...icon, rotation: heading });
            }
          } catch (_) {}

          driverMarker.setPosition(newPos);
          if (segIndex % 8 === 0) {
            try { map.panTo(newPos); } catch (_) {}
          }
        } catch (_) {
          // ignore
        }
      }, 1000);
    }

    function loadGoogleMaps(key) {
      return new Promise((resolve, reject) => {
        if (window.google && window.google.maps) return resolve();
        const script = document.createElement("script");
        script.src = `https://maps.googleapis.com/maps/api/js?key=${encodeURIComponent(key)}&libraries=places,geometry`;
        script.async = true;
        script.defer = true;
        script.onload = () => resolve();
        script.onerror = () => reject(new Error("Failed to load Google Maps"));
        document.head.appendChild(script);
      });
    }

    // Pyodide setup
    let pyodide;
    async function initPyodideAndPython() {
      pyodide = await loadPyodide();
      await pyodide.runPythonAsync(`
import base64, hashlib, secrets, time

# Matches encrypt_keys.py

def decrypt_key(encrypted_data: str, passphrase: str = "default_salt_2024") -> str:
    encrypted_bytes = base64.b64decode(encrypted_data)
    key_hash = hashlib.sha256(passphrase.encode()).digest()
    decrypted = bytearray()
    for i, b in enumerate(encrypted_bytes):
        decrypted.append(b ^ key_hash[i % len(key_hash)])
    return decrypted.decode("utf-8")

# OTP helpers

def generate_otp() -> str:
    return f"{secrets.randbelow(1_000_000):06d}"

def otp_hash(phone: str, otp: str) -> str:
    # simple local hash (demo), not for production
    return hashlib.sha256((phone + "|" + otp).encode()).hexdigest()

# Fare estimator (demo)

def estimate_fare(distance_km: float, duration_min: float, trip_type: str) -> float:
    base = 149.0
    per_km = 18.0
    per_min = 2.5

    multiplier = 1.0
    if trip_type == "round_trip":
        multiplier = 1.35
    elif trip_type == "hourly":
        multiplier = 1.15
    elif trip_type == "after_party":
        multiplier = 1.25

    fare = (base + (per_km * max(distance_km, 0.0)) + (per_min * max(duration_min, 0.0))) * multiplier
    return round(fare, 0)
`);
    }

    // Login/register/OTP (local ‚Äúbackend‚Äù)
    $("register").addEventListener("click", async () => {
      try {
        const phone = normalizePhone($("phone").value);
        const db = getDb();
        db.users = db.users || {};
        if (!db.users[phone]) {
          db.users[phone] = { phone, createdAt: Date.now(), verifiedAt: null };
          setDb(db);
        }
        setLoginMsg(`Registered: ${phone}`);
      } catch (e) {
        setLoginMsg(e.message || String(e));
      }
    });

    $("genOtp").addEventListener("click", async () => {
      try {
        if (!pyodide) throw new Error("Pyodide not ready yet");
        const phone = normalizePhone($("phone").value);
        const db = getDb();
        db.users = db.users || {};
        db.otps = db.otps || {};

        if (!db.users[phone]) {
          db.users[phone] = { phone, createdAt: Date.now(), verifiedAt: null };
        }

        const otp = await pyodide.runPythonAsync(`generate_otp()`);
        const hash = await pyodide.runPythonAsync(`otp_hash("${phone}", "${otp}")`);
        const expiresAt = Date.now() + (5 * 60 * 1000);
        db.otps[phone] = { hash, expiresAt };
        setDb(db);

        // Demo ‚Äúdelivery‚Äù: show OTP to user
        setLoginMsg(`OTP (demo): ${otp} (valid 5 min)`);
        $("otp").value = String(otp);
      } catch (e) {
        setLoginMsg(e.message || String(e));
      }
    });

    $("verify").addEventListener("click", async () => {
      try {
        if (!pyodide) throw new Error("Pyodide not ready yet");
        const phone = normalizePhone($("phone").value);
        const otp = String($("otp").value || "").trim();
        if (!otp) throw new Error("OTP is required");

        const db = getDb();
        const rec = db.otps?.[phone];
        if (!rec) throw new Error("No OTP requested for this number");
        if (Date.now() > rec.expiresAt) throw new Error("OTP expired");

        const hash = await pyodide.runPythonAsync(`otp_hash("${phone}", "${otp}")`);
        if (String(hash) !== String(rec.hash)) throw new Error("Invalid OTP");

        db.users = db.users || {};
        if (!db.users[phone]) db.users[phone] = { phone, createdAt: Date.now(), verifiedAt: null };
        db.users[phone].verifiedAt = Date.now();
        setDb(db);

        setSession({ phone, verified: true, at: Date.now() });
        updateHeaderAuthUI();
        showLogin(false);
        setMsg("Logged in. You can book now.");
      } catch (e) {
        setLoginMsg(e.message || String(e));
      }
    });

    // Directions + fare
    async function computeAndRenderRoute(render) {
      if (!pickupPlace || !dropPlace) throw new Error("Select both pickup and drop from suggestions");

      const request = {
        origin: pickupPlace.geometry.location,
        destination: dropPlace.geometry.location,
        travelMode: google.maps.TravelMode.DRIVING,
        drivingOptions: {
          departureTime: new Date(),
          trafficModel: google.maps.TrafficModel.BEST_GUESS,
        },
      };

      const res = await directionsService.route(request);
      const leg = res.routes?.[0]?.legs?.[0];
      if (!leg) throw new Error("No route found");

      $("dist").textContent = leg.distance?.text || "‚Äî";

      // Prefer live-traffic duration when available.
      const durTraffic = leg.duration_in_traffic;
      const durNormal = leg.duration;
      if (durTraffic?.text) {
        $("dur").textContent = `${durTraffic.text} (traffic)`;
      } else {
        $("dur").textContent = durNormal?.text || "‚Äî";
      }

      const distanceKm = (leg.distance?.value || 0) / 1000;

      // Use traffic seconds if available, otherwise normal.
      const durationSeconds = (durTraffic?.value ?? durNormal?.value ?? 0);
      const durationMin = durationSeconds / 60;

      const fare = await pyodide.runPythonAsync(`estimate_fare(${distanceKm}, ${durationMin}, "${tripType}")`);
      $("fare").textContent = `‚Çπ${fare}`;

      if (render) {
        directionsRenderer.setDirections(res);
        try {
          const bounds = res.routes?.[0]?.bounds;
          if (bounds) map.fitBounds(bounds, 48);
        } catch (_) {}

        // Add nicer pickup/drop markers.
        const origin = pickupPlace.geometry?.location;
        const dest = dropPlace.geometry?.location;
        if (origin) {
          if (!pickupMarker) {
            pickupMarker = new google.maps.Marker({
              map,
              position: origin,
              label: { text: "P", color: "#ffffff", fontWeight: "800" },
              icon: {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 10,
                fillColor: "#2b6cff",
                fillOpacity: 1,
                strokeColor: "#ffffff",
                strokeWeight: 2,
              },
              title: "Pickup",
            });
          } else {
            pickupMarker.setPosition(origin);
          }
        }
        if (dest) {
          if (!dropMarker) {
            dropMarker = new google.maps.Marker({
              map,
              position: dest,
              label: { text: "D", color: "#ffffff", fontWeight: "800" },
              icon: {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 10,
                fillColor: "#2b6cff",
                fillOpacity: 1,
                strokeColor: "#ffffff",
                strokeWeight: 2,
              },
              title: "Drop",
            });
          } else {
            dropMarker.setPosition(dest);
          }
        }
      }
      return { distanceKm, durationMin };
    }

    $("routeBtn").addEventListener("click", async () => {
      try {
        setMsg("Calculating route‚Ä¶");
        await computeAndRenderRoute(true);
        setMsg("Route updated.");
      } catch (e) {
        setMsg(e.message || String(e));
      }
    });

    $("findBtn").addEventListener("click", async () => {
      try {
        if (!isAuthed()) {
          showLogin(true);
          setLoginMsg("Login required to proceed.");
          return;
        }

        setMsg("Calculating estimate‚Ä¶");
        const route = await computeAndRenderRoute(true);

        // Capture booking in local ‚Äúbackend‚Äù
        const session = getSession();
        const db = getDb();
        db.bookings = db.bookings || [];
        const bookingId = uid("bk");
        activeBookingId = bookingId;
        db.bookings.push({
          id: bookingId,
          phone: session.phone,
          createdAt: Date.now(),
          status: "created",
          tripType,
          pickupText: $("pickup").value,
          dropText: $("drop").value,
          date: $("date").value,
          time: $("time").value,
          distanceKm: route.distanceKm,
          durationMin: route.durationMin,
        });
        setDb(db);

        // Show driver selection
        showDriversPanel(true);
        setDriversStatus("Select a driver to send a request.");
        renderDriversList(bookingId);

        setMsg("Request captured (local). Choose a driver below.");
      } catch (e) {
        setMsg(e.message || String(e));
      }
    });

    // Boot
    async function init() {
      updateHeaderAuthUI();
      setMsg("Loading Pyodide‚Ä¶");

      // Improve calendar/time picker UX (uses native pickers where supported).
      const dateEl = $("date");
      const timeEl = $("time");
      const tryShowPicker = (el) => {
        try {
          if (el && typeof el.showPicker === "function") el.showPicker();
        } catch (_) {
          // ignore
        }
      };
      if (dateEl) {
        dateEl.addEventListener("focus", () => tryShowPicker(dateEl));
        dateEl.addEventListener("click", () => tryShowPicker(dateEl));
        if (!dateEl.value) {
          const now = new Date();
          const yyyy = now.getFullYear();
          const mm = String(now.getMonth() + 1).padStart(2, "0");
          const dd = String(now.getDate()).padStart(2, "0");
          dateEl.value = `${yyyy}-${mm}-${dd}`;
        }
      }
      if (timeEl) {
        timeEl.addEventListener("focus", () => tryShowPicker(timeEl));
        timeEl.addEventListener("click", () => tryShowPicker(timeEl));
        if (!timeEl.value) {
          const now = new Date();
          const mins = now.getMinutes();
          const rounded = mins + (15 - (mins % 15 || 15));
          now.setMinutes(rounded, 0, 0);
          const hh = String(now.getHours()).padStart(2, "0");
          const mi = String(now.getMinutes()).padStart(2, "0");
          timeEl.value = `${hh}:${mi}`;
        }
      }

      try {
        await initPyodideAndPython();

        setMsg("Decrypting Maps key‚Ä¶");
        const key = await pyodide.runPythonAsync(`decrypt_key("${GMAPS_KEY_ENCRYPTED}", "${PASSPHRASE}")`);
        if (!key) throw new Error("Failed to decrypt Maps key");

        setMsg("Loading Google Maps‚Ä¶");
        await loadGoogleMaps(key);

        map = new google.maps.Map($("map"), {
          center: { lat: 12.9716, lng: 77.5946 },
          zoom: 12,
          mapTypeControl: false,
          streetViewControl: false,
          fullscreenControl: false,
        });

        // Show live traffic overlay.
        trafficLayer = new google.maps.TrafficLayer();
        trafficLayer.setMap(map);

        geocoder = new google.maps.Geocoder();

        directionsService = new google.maps.DirectionsService();
        directionsRenderer = new google.maps.DirectionsRenderer({
          map,
          suppressMarkers: true,
          polylineOptions: {
            strokeColor: "#2b6cff",
            strokeOpacity: 0.9,
            strokeWeight: 6,
          },
        });

        pickupAutocomplete = new google.maps.places.Autocomplete($("pickup"));
        dropAutocomplete = new google.maps.places.Autocomplete($("drop"));
        pickupAutocomplete.addListener("place_changed", () => {
          pickupPlace = pickupAutocomplete.getPlace();
          updateButtons();
        });
        dropAutocomplete.addListener("place_changed", () => {
          dropPlace = dropAutocomplete.getPlace();
          updateButtons();
        });

        // Track which field the user wants to set.
        $("pickup").addEventListener("focus", () => { lastFocusedField = "pickup"; });
        $("drop").addEventListener("focus", () => { lastFocusedField = "drop"; });

        // Click-to-set on map (focus pickup/drop first).
        map.addListener("click", async (e) => {
          try {
            if (!e.latLng) return;
            await setFieldFromLatLng(lastFocusedField, e.latLng, { centerMap: true });
          } catch (err) {
            setMsg(err.message || String(err));
          }
        });

        // Use current location once
        $("useMyLocation").addEventListener("click", async () => {
          try {
            setMsg("Getting your location‚Ä¶");
            const pos = await getCurrentPosition();
            const latLng = new google.maps.LatLng(pos.coords.latitude, pos.coords.longitude);
            await setFieldFromLatLng("pickup", latLng, { centerMap: true, accuracyMeters: pos.coords.accuracy });
            setMsg("Pickup set to your current location.");
          } catch (err) {
            setMsg(err.message || String(err));
          }
        });

        // Use current location for drop (one-time)
        $("useMyLocationDrop").addEventListener("click", async () => {
          try {
            setMsg("Getting your location‚Ä¶");
            const pos = await getCurrentPosition();
            const latLng = new google.maps.LatLng(pos.coords.latitude, pos.coords.longitude);
            await setFieldFromLatLng("drop", latLng, { centerMap: true, accuracyMeters: pos.coords.accuracy });
            setMsg("Drop set to your current location.");
          } catch (err) {
            setMsg(err.message || String(err));
          }
        });

        // Toggle live location tracking
        $("trackMe").addEventListener("click", async () => {
          try {
            if (geoWatchId !== null) {
              stopTracking();
              $("trackMe").textContent = "Track me";
              setMsg("Tracking stopped.");
              return;
            }

            setMsg("Starting live tracking‚Ä¶");
            await startTracking();
            $("trackMe").textContent = "Stop tracking";
            setMsg("Tracking enabled.");
          } catch (err) {
            setMsg(err.message || String(err));
          }
        });

        updateButtons();
        setMsg("Ready.");

        // Driver panel controls + restore last booking state
        $("closeDrivers").addEventListener("click", () => showDriversPanel(false));

        try {
          const session = getSession();
          if (session?.phone) {
            const db = getDb();
            const last = (db.bookings || []).slice().reverse().find((b) => b && b.phone === session.phone);
            if (last && (last.status === "requested" || last.status === "accepted" || last.status === "arrived")) {
              activeBookingId = last.id;
              showDriversPanel(true);
              if (last.status === "accepted") {
                setDriversStatus(`Accepted by ${last.driver?.name || "driver"}.`);
                // If pickupPlace is available (in this session), resume movement simulation.
                try { startDriverSimulationTowardPickup(last.id); } catch (_) {}
              } else if (last.status === "arrived") {
                setDriversStatus(`Driver arrived at pickup: ${last.driver?.name || "driver"}.`);
              } else {
                setDriversStatus(`Request sent to ${last.driver?.name || "driver"}. Waiting for acceptance‚Ä¶`);
              }
              renderDriversList(last.id);
            }
          }
        } catch (_) {
          // ignore restore errors
        }
      } catch (e) {
        setMsg(e.message || String(e));
      }
    }

    function ensureGeoAvailable() {
      if (!navigator.geolocation) {
        throw new Error("Geolocation is not available in this browser");
      }
      // Most browsers require https (or localhost) for geolocation.
    }

    function getCurrentPosition() {
      ensureGeoAvailable();
      return new Promise((resolve, reject) => {
        navigator.geolocation.getCurrentPosition(resolve, reject, {
          enableHighAccuracy: true,
          timeout: 15000,
          maximumAge: 0,
        });
      });
    }

    async function reverseGeocode(latLng) {
      if (!geocoder) throw new Error("Geocoder not initialized");
      const res = await geocoder.geocode({ location: latLng });
      const best = res.results?.[0];
      return best ? best.formatted_address : "";
    }

    function updateUserMarker(latLng, accuracyMeters) {
      if (!map) return;
      if (!userMarker) {
        userMarker = new google.maps.Marker({
          map,
          position: latLng,
          title: "Your location",
        });
      } else {
        userMarker.setPosition(latLng);
      }

      if (typeof accuracyMeters === "number") {
        if (!userAccuracyCircle) {
          userAccuracyCircle = new google.maps.Circle({
            map,
            center: latLng,
            radius: accuracyMeters,
            strokeColor: "#2b6cff",
            strokeOpacity: 0.6,
            strokeWeight: 2,
            fillColor: "#2b6cff",
            fillOpacity: 0.12,
          });
        } else {
          userAccuracyCircle.setCenter(latLng);
          userAccuracyCircle.setRadius(accuracyMeters);
        }
      }
    }

    async function setFieldFromLatLng(field, latLng, options) {
      const { centerMap, accuracyMeters } = options || {};
      const address = await reverseGeocode(latLng);
      if (!address) throw new Error("Could not resolve address for this point");

      const placeLike = {
        geometry: { location: latLng },
        formatted_address: address,
        name: address,
      };

      if (field === "pickup") {
        $("pickup").value = address;
        pickupPlace = placeLike;
      } else {
        $("drop").value = address;
        dropPlace = placeLike;
      }

      updateButtons();
      updateUserMarker(latLng, accuracyMeters);
      if (centerMap) {
        map.panTo(latLng);
        map.setZoom(Math.max(map.getZoom() || 12, 15));
      }
    }

    async function startTracking() {
      ensureGeoAvailable();
      if (!map) throw new Error("Map not ready");

      geoWatchId = navigator.geolocation.watchPosition(
        async (pos) => {
          try {
            const latLng = new google.maps.LatLng(pos.coords.latitude, pos.coords.longitude);
            updateUserMarker(latLng, pos.coords.accuracy);
            // If pickup isn't set yet, keep it aligned to live location.
            if (!pickupPlace) {
              await setFieldFromLatLng("pickup", latLng, { centerMap: false, accuracyMeters: pos.coords.accuracy });
            }
          } catch (_) {
            // Avoid spamming messages during tracking.
          }
        },
        (err) => {
          stopTracking();
          $("trackMe").textContent = "Track me";
          setMsg(err.message || "Unable to track location");
        },
        {
          enableHighAccuracy: true,
          timeout: 15000,
          maximumAge: 0,
        }
      );
    }

    function stopTracking() {
      if (geoWatchId !== null) {
        navigator.geolocation.clearWatch(geoWatchId);
        geoWatchId = null;
      }
    }

    init();
  </script>
</body>
</html>
